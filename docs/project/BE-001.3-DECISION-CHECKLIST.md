# BE-001.3 Distributed Locks - Decision Checklist for Meeting

> **Meeting**: Monday, November 18, 2025 @ 10:00 AM  
> **Attendees**: PM, UI Team, Backend Team, Consultants  
> **Purpose**: Finalize design decisions before implementation (Week 3-4)  
> **Status**: ‚ö†Ô∏è CRITICAL - Blocks production deployment

---

## üéØ Meeting Agenda (60 minutes)

1. **Review UI Team Feedback** (10 min) - Critical gap: no editor locking
2. **Clarify Requirements** (20 min) - Answer 8 critical questions below
3. **Approve Technical Design** (15 min) - Review spec document
4. **Define Acceptance Criteria** (10 min) - What "done" means
5. **Set Timeline** (5 min) - Confirm Week 3-4 delivery

---

## üö® CRITICAL DECISIONS (Must be answered in meeting)

### **DECISION 1: Viewer Permission Model** ‚úÖ **DECIDED**

**Context**: "Tutti gli utenti possono essere viewer se concesso dall'editor"

**Question**: How do we enforce "se concesso dall'editor"?

**Options**:

- **A) No WebSocket permission check** (auth handled upstream by JWT/ACLs) ‚Üê ‚úÖ **APPROVED**
- B) Editor whitelist (approval required before viewing)
- C) Editor blacklist (editor can kick viewers)

**Decision**: ‚úÖ **Option A** (No WebSocket permission check)

**Rationale**:

- Separation of concerns: WebSocket = sync layer, Auth service = permissions
- Simpler implementation (Week 3 vs Week 4-5)
- Standard pattern (Socket.IO, Firebase, Pusher all use upstream auth)
- JWT claims already contain resource permissions

**Implementation Impact**:

- WebSocket Gateway checks JWT validity, NOT resource-level viewer permissions
- Resource ACLs managed by upstream auth service (e.g., Keycloak, custom DB)
- If user has valid JWT with resource access ‚Üí Can join as viewer
- If editor needs control ‚Üí Must be implemented in application layer (not WebSocket)

**Acceptance Criteria**:

- [ ] JWT validation rejects invalid/expired tokens
- [ ] User with valid JWT can join as viewer (no editor approval needed)
- [ ] Editor lock prevents second editor (auto-downgrade to viewer)
- [ ] No viewer limit enforced (unless configured per resource type)

---

### **DECISION 2: Lock Upgrade Flow** ‚è≥ **PENDING**

**Context**: Viewer wants to become editor, but lock already held by another user.

**Question**: What happens when viewer requests editor upgrade?

**Options**:

#### **A) Immediate Deny + Notification** (Simplest - Week 3)

```
User B (Viewer): Requests lock upgrade
Server: Checks lock ‚Üí Already held by User A
Server ‚Üí User B: lock:denied { currentHolder: "Dr. Smith", expiresAt: 1234567890 }
User B: Sees notification "Dr. Smith is editing, lock expires in 4 min"
```

**Pros**: Simple, immediate feedback, ships Week 3  
**Cons**: User blocked, no recourse except waiting for TTL expiry

---

#### **B) Queue + Notify When Available** (Fair - Week 4)

```
User B (Viewer): Requests lock upgrade
Server: Adds User B to queue (Redis LIST)
Server ‚Üí User B: lock:queued { position: 2, estimatedWait: "3 min" }
[When User A releases or lock expires]
Server ‚Üí User B: lock:your_turn { resourceId }
User B: Claims lock within 30s or goes to next in queue
```

**Pros**: Fair, FIFO order, good UX for busy resources  
**Cons**: Complex (queue management, timeouts, dead letter), ships Week 4

---

#### **C) "Request Lock" Button + Push Notification** (Collaborative - Week 4)

```
User B (Viewer): Clicks "Request Lock" ‚Üí Sends message to editor
Server ‚Üí User A (Editor): lock:request_received {
  from: "Nurse Jane",
  message: "Need to add diagnosis",
  actions: ["APPROVE", "DENY", "IGNORE"]
}

IF User A approves:
  User A releases lock voluntarily
  Server ‚Üí User B: lock:available { resourceId }

IF User A denies or ignores (timeout 2 min):
  Server ‚Üí User B: lock:request_timeout { message: "Dr. Smith still editing" }
```

**Pros**: Human collaboration, polite, works in healthcare (team communication)  
**Cons**: Relies on holder responding, not guaranteed, ships Week 4

---

**ü§î QUESTION FOR MEETING**:

**Which lock upgrade flow do you prefer?**

- [ ] **Option A**: Immediate deny + notification (simple, Week 3)
- [ ] **Option B**: Queue + notify (fair, Week 4)
- [ ] **Option C**: "Request Lock" button (collaborative, Week 4)

**PM/UI Team Recommendation**: **************\_\_**************

**Backend Recommendation**: **Option A** for Phase 1 (Week 3), **Option C** for Phase 2 (Week 4) if time permits.

**Decision**: **************\_\_**************

---

### **DECISION 3: Lock Holder Disconnect Handling** ‚è≥ **PENDING**

**Context**: Lock holder loses connection unexpectedly (network issue, browser crash, laptop closed).

**Question**: How long do we wait before releasing lock?

**Options**:

#### **A) Immediate Release** (Fast - Week 3)

```typescript
async handleDisconnect(client: Socket) {
  // Release ALL locks held by disconnected user immediately
  await this.redis.releaseAllLocks(userId);
  this.server.emit('lock:released', { reason: 'DISCONNECT' });
}
```

**Pros**: Lock available immediately for others  
**Cons**: False positives (temporary WiFi glitch = lose lock and unsaved work)

---

#### **B) 30-Second Grace Period** (Forgiving - Week 3)

```typescript
async handleDisconnect(client: Socket) {
  // Mark locks as "grace period" for 30 seconds
  await this.redis.setGracePeriod(userId, lockedResources, 30000);

  setTimeout(async () => {
    if (!this.isUserConnected(userId)) {
      // Still disconnected after 30s ‚Üí Release locks
      await this.redis.releaseAllLocks(userId);
      this.server.emit('lock:released', { reason: 'GRACE_PERIOD_EXPIRED' });
    }
  }, 30000);
}
```

**Pros**: Survives temporary network issues, user can reconnect and keep lock  
**Cons**: Others wait 30s even if true disconnect (laptop died, went home)

---

#### **C) Prompt Other Users** (Democratic - Week 4)

```typescript
async handleDisconnect(client: Socket) {
  // Ask viewers: "Lock holder disconnected, claim now or wait 30s?"
  this.server.to(resourceId).emit('lock:holder_disconnected', {
    holder: userId,
    actions: ['CLAIM_NOW', 'WAIT_30S'],
  });

  // First to claim gets lock, OR auto-release after 30s if no claim
}
```

**Pros**: Flexible (urgent = claim now, can wait = wait 30s)  
**Cons**: Race condition if multiple claim simultaneously, complex

---

**ü§î QUESTION FOR MEETING**:

**How should we handle lock holder disconnect?**

- [ ] **Option A**: Immediate release (fast, Week 3)
- [ ] **Option B**: 30-second grace period (forgiving, Week 3) ‚Üê **Recommended**
- [ ] **Option C**: Prompt other users (democratic, Week 4)

**PM/UI Team Recommendation**: **************\_\_**************

**Backend Recommendation**: **Option B** (30-second grace period) - balances availability and forgiveness.

**Decision**: **************\_\_**************

---

### **DECISION 4: Tab Lock Limits** ‚è≥ **PENDING**

**Context**: User editing multiple tabs/sections in same document (e.g., `doc:123:patient`, `doc:123:diagnosis`, `doc:123:medications`).

**Question**: Should we limit how many tabs one user can lock simultaneously?

**Options**:

#### **A) No Limit** (Unlimited - Week 3)

```typescript
// User can lock as many child resources as needed
User A locks: doc:123:patient      ‚úÖ
User A locks: doc:123:diagnosis    ‚úÖ
User A locks: doc:123:medications  ‚úÖ
User A locks: doc:123:procedures   ‚úÖ
// ... (no limit)
```

**Pros**: Maximum flexibility, simple  
**Cons**: Risk of hoarding (user locks all tabs, forgets to release)

---

#### **B) Fixed Limit (5 tabs)** (Fair - Week 3)

```typescript
MAX_CONCURRENT_TAB_LOCKS_PER_USER = 5;

// User can lock max 5 tabs simultaneously
User A locks: doc:123:patient      ‚úÖ (1/5)
User A locks: doc:123:diagnosis    ‚úÖ (2/5)
User A locks: doc:123:medications  ‚úÖ (3/5)
User A locks: doc:123:procedures   ‚úÖ (4/5)
User A locks: doc:123:notes        ‚úÖ (5/5)
User A locks: doc:123:images       ‚ùå MAX_TAB_LOCKS_EXCEEDED
```

**Pros**: Prevents hoarding, fair distribution  
**Cons**: Arbitrary limit (why 5? why not 10?)

---

#### **C) Configurable Per Resource Type** (Flexible - Week 4)

```yaml
resourceTypes:
  document:
    maxConcurrentTabLocksPerUser: 3

  operation-report:
    maxConcurrentTabLocksPerUser: 5

  patient-chart:
    maxConcurrentTabLocksPerUser: 10
```

**Pros**: Domain-specific flexibility (simple docs = 3, complex reports = 10)  
**Cons**: More configuration complexity

---

**ü§î QUESTION FOR MEETING**:

**Should we limit concurrent tab locks per user?**

- [ ] **Option A**: No limit (simplest, Week 3)
- [ ] **Option B**: Fixed limit (5 tabs) (fair, Week 3) ‚Üê **Recommended**
- [ ] **Option C**: Configurable per resource type (flexible, Week 4)

**PM/UI Team Recommendation**: **************\_\_**************

**Backend Recommendation**: **Option B** (5 tabs fixed) as sensible default, make configurable later if needed.

**Decision**: **************\_\_**************

---

### **DECISION 5: Admin Force Takeover** ‚è≥ **PENDING**

**Context**: Surgeon needs to edit urgently (emergency surgery update), but nurse holds lock.

**Question**: Can admin/surgeon forcefully take lock from another user?

**Options**:

#### **A) Immediate Takeover** (Fast - Week 3)

```typescript
// Admin/surgeon can take lock immediately, no confirmation
async adminTakeover(resourceId: string, adminUserId: string, reason: string) {
  const currentHolder = await this.redis.getLockHolder(resourceId);

  // Force release
  await this.redis.releaseLock(resourceId, currentHolder.userId);

  // Admin acquires
  await this.redis.acquireLock(resourceId, adminUserId, TTL);

  // Audit log
  await this.auditLog.log({
    action: 'LOCK_TAKEOVER',
    admin: adminUserId,
    previousHolder: currentHolder.userId,
    reason,
  });

  // Notify previous holder
  this.server.to(currentHolder.socketId).emit('lock:taken_by_admin', {
    admin: adminUserId,
    reason,
  });
}
```

**Pros**: Fast, supports surgical emergencies  
**Cons**: Disruptive (holder loses lock immediately, may have unsaved work)

---

#### **B) Request Approval (30s timeout)** (Polite - Week 4)

```typescript
// Admin requests takeover, holder can approve or gets forced after 30s
Server ‚Üí Holder: lock:takeover_requested {
  from: "Dr. Chief",
  reason: "Emergency surgery update",
  actions: ["APPROVE", "DENY", "AUTO_FORCE_IN_30S"]
}

IF Holder approves:
  Holder releases gracefully (can save work first)
  Admin gets lock

IF Holder denies or timeout (30s):
  Force takeover (same as Option A)
```

**Pros**: Polite, gives holder chance to save work  
**Cons**: 30-second delay (acceptable for most cases, not true emergencies)

---

#### **C) No Force Takeover** (Wait for TTL - Week 3)

```typescript
// No admin override, must wait for lock TTL expiry (5 min)
// Rely on lock timeout mechanism
```

**Pros**: Simplest, no special logic  
**Cons**: Admin blocked for up to 5 minutes (unacceptable for emergencies)

---

**ü§î QUESTION FOR MEETING**:

**Should we allow admin force takeover?**

- [ ] **Option A**: Immediate takeover (fast, Week 3)
- [ ] **Option B**: Request approval with 30s timeout (polite, Week 4) ‚Üê **Recommended**
- [ ] **Option C**: No force takeover (simplest, Week 3)

**PM/UI Team Recommendation**: **************\_\_**************

**Backend Recommendation**: **Option B** (request approval with timeout) - balances urgency and courtesy.

**Healthcare Consultant Input Needed**: Is 30-second delay acceptable for emergency scenarios?

**Decision**: **************\_\_**************

---

### **DECISION 6: Lock TTL (Time-To-Live)** ‚è≥ **PENDING**

**Context**: Lock expires automatically if no heartbeat received.

**Question**: What should default lock TTL be?

**Options**:

| TTL Value                   | Use Case                            | Pros                                | Cons                           |
| --------------------------- | ----------------------------------- | ----------------------------------- | ------------------------------ |
| **2 minutes**               | Quick edits (add note, fix typo)    | Fast recovery if holder disconnects | Too short for complex edits    |
| **5 minutes** ‚Üê Recommended | Balanced (most edits done in 5 min) | Good balance                        | May be too short for reports   |
| **10 minutes**              | Complex edits (operation reports)   | Enough time for detailed work       | Lock held longer if disconnect |
| **Configurable**            | Per resource type (2/5/10 min)      | Flexible per domain                 | More config complexity         |

**ü§î QUESTION FOR MEETING**:

**What should default lock TTL be?**

- [ ] 2 minutes (quick edits)
- [ ] 5 minutes (balanced) ‚Üê **Recommended**
- [ ] 10 minutes (complex edits)
- [ ] Configurable per resource type

**PM/UI Team Recommendation**: **************\_\_**************

**Backend Recommendation**: **5 minutes default**, configurable per resource type if needed.

**Decision**: **************\_\_**************

---

### **DECISION 7: Viewer Limits Per Resource Type** ‚è≥ **PENDING**

**Context**: Unlimited viewers allowed by default, but may want limits for sensitive data or performance.

**Question**: Should we enforce max viewers per child resource?

**Options**:

#### **A) No Limits** (Unlimited - Week 3)

```yaml
default:
  maxViewersPerChild: null # null = unlimited
```

**Pros**: Simplest, maximizes collaboration  
**Cons**: Potential performance issue (100+ viewers on one resource)

---

#### **B) Global Limit** (e.g., 100 viewers - Week 3)

```yaml
default:
  maxViewersPerChild: 100 # Reasonable limit to prevent abuse
```

**Pros**: Simple, prevents abuse  
**Cons**: Arbitrary limit (why 100? why not 200?)

---

#### **C) Configurable Per Resource Type** (Flexible - Week 3)

```yaml
resourceTypes:
  operation-report:
    maxViewersPerChild: 10 # Sensitive data, fewer viewers

  patient-chart:
    maxViewersPerChild: null # Unlimited (collaborative)

  document:
    maxViewersPerChild: 50 # Reasonable limit
```

**Pros**: Domain-specific security (sensitive docs = fewer viewers)  
**Cons**: Requires resource type configuration

---

**ü§î QUESTION FOR MEETING**:

**Should we enforce viewer limits?**

- [ ] **Option A**: No limits (unlimited, Week 3)
- [ ] **Option B**: Global limit (100 viewers, Week 3)
- [ ] **Option C**: Configurable per resource type (Week 3) ‚Üê **Recommended**

**PM/UI Team Recommendation**: **************\_\_**************

**Security Consultant Input Needed**: Are there compliance requirements (HIPAA) for limiting viewers on sensitive data?

**Backend Recommendation**: **Option C** (configurable per type) - allows security for sensitive docs while keeping others open.

**Decision**: **************\_\_**************

---

### **DECISION 8: Heartbeat Interval** ‚è≥ **PENDING**

**Context**: Client sends heartbeat to renew lock, preventing TTL expiry while actively editing.

**Question**: How often should client send heartbeat?

**Options**:

| Interval                     | Pros                                           | Cons                                       | Network Traffic    |
| ---------------------------- | ---------------------------------------------- | ------------------------------------------ | ------------------ |
| **30 seconds**               | Responsive (quick detection of inactive users) | More network traffic                       | High (2 msg/min)   |
| **60 seconds** ‚Üê Recommended | Balanced (good detection + low traffic)        | Moderate detection time                    | Medium (1 msg/min) |
| **120 seconds**              | Minimal traffic                                | Slow detection (2+ min to detect inactive) | Low (0.5 msg/min)  |

**ü§î QUESTION FOR MEETING**:

**What should heartbeat interval be?**

- [ ] 30 seconds (responsive)
- [ ] 60 seconds (balanced) ‚Üê **Recommended**
- [ ] 120 seconds (low traffic)

**PM/UI Team Recommendation**: **************\_\_**************

**Backend Recommendation**: **60 seconds** (every 1 minute) - balances responsiveness and network efficiency.

**Decision**: **************\_\_**************

---

## üìã Additional Clarifications Needed

### **CLARIFICATION 1: Resource ID Normalization** ‚è≥ **PENDING**

**Context**: Backend auto-appends `:main` if client sends 2-part ID (`document:123` ‚Üí `document:123:main`).

**Question**: Is this backward-compatible normalization acceptable?

**Example**:

```typescript
// Client (old code)
socket.emit('resource:join', { resourceId: 'document:123', mode: 'editor' });

// Server normalizes internally
const normalized = 'document:123:main';

// Client receives
socket.on('lock:acquired', { resourceId: 'document:123:main' });
```

**Impact**:

- ‚úÖ Clients must handle 3-part IDs in responses
- ‚úÖ UI can continue sending 2-part IDs (backward compatible)
- ‚ö†Ô∏è UI should migrate to always sending 3-part IDs

**ü§î QUESTION FOR MEETING**: Is backward-compatible normalization OK, or should we require 3-part IDs from day 1?

**Decision**: **************\_\_**************

---

### **CLARIFICATION 2: Lock Holder Information in Presence** ‚è≥ **PENDING**

**Context**: When lock is held, should we include holder info in presence list?

**Question**: What info should we expose about lock holder?

**Options**:

#### **A) Minimal** (userId only)

```typescript
{
  resourceId: 'doc:123:main',
  users: [
    { userId: 'user-a', mode: 'editor', hasLock: true },
    { userId: 'user-b', mode: 'viewer', hasLock: false },
  ]
}
```

**Pros**: Privacy-preserving  
**Cons**: UI can't show "Dr. Smith is editing"

---

#### **B) Full Info** (userId + username + lockExpiresAt)

```typescript
{
  resourceId: 'doc:123:main',
  users: [
    {
      userId: 'user-a',
      username: 'Dr. John Smith',
      mode: 'editor',
      hasLock: true,
      lockExpiresAt: 1234567890,
    },
    { userId: 'user-b', username: 'Nurse Jane', mode: 'viewer', hasLock: false },
  ]
}
```

**Pros**: Rich UI (can show "Dr. Smith is editing, lock expires in 4 min")  
**Cons**: More data in every presence update

---

**ü§î QUESTION FOR MEETING**: How much lock holder info should we expose in presence?

**Decision**: **************\_\_**************

---

### **CLARIFICATION 3: Multi-Instance Redis** ‚è≥ **PENDING**

**Context**: BE-001.3 uses Redis for locks. What about horizontal scaling (multiple backend instances)?

**Question**: Are we planning multi-instance deployment in Phase 1?

**Options**:

#### **A) Single Instance (Week 3)** ‚Üê Recommended for Phase 1

- Use Redis for locks (shared state across connections)
- No Redis Pub/Sub or Streams yet (deferred to BE-001.5)
- Sufficient for initial production (< 1000 concurrent users)

---

#### **B) Multi-Instance (Week 5-6)** ‚Üê Planned for BE-001.5

- Add Redis Streams for cross-instance event broadcasting
- Lock state already shared (Redis atomic operations)
- Scales to 10k+ concurrent users

---

**ü§î QUESTION FOR MEETING**: Can we defer multi-instance to BE-001.5, or is it required for Phase 1?

**Decision**: **************\_\_**************

---

## ‚úÖ Pre-Approved Decisions (No Meeting Discussion Needed)

### ‚úÖ **APPROVED: Viewer Permission Model**

**Decision**: Option A (No WebSocket permission check, auth handled upstream)

**Confirmed By**: Backend Team, Saturday Nov 16, 2025

---

### ‚úÖ **APPROVED: Canonical Resource ID Pattern**

**Decision**: All resources follow `type:uuid:child` format (auto-append `:main` if missing)

**Confirmed By**: Backend Team, Saturday Nov 16, 2025

---

### ‚úÖ **APPROVED: Max Editors Per Child**

**Decision**: ALWAYS 1 editor per child resource (immutable rule, non-configurable)

**Confirmed By**: Backend Team, Saturday Nov 16, 2025

---

## üìä Summary Table (For Quick Reference)

| Decision               | Options       | Recommended               | Status      |
| ---------------------- | ------------- | ------------------------- | ----------- |
| 1. Viewer Permission   | A/B/C         | A (upstream auth)         | ‚úÖ Approved |
| 2. Lock Upgrade Flow   | A/B/C         | A (Phase 1), C (Phase 2)  | ‚è≥ Pending  |
| 3. Disconnect Handling | A/B/C         | B (30s grace)             | ‚è≥ Pending  |
| 4. Tab Lock Limits     | A/B/C         | B (5 tabs)                | ‚è≥ Pending  |
| 5. Admin Takeover      | A/B/C         | B (request + 30s timeout) | ‚è≥ Pending  |
| 6. Lock TTL            | 2/5/10/Config | 5 min default             | ‚è≥ Pending  |
| 7. Viewer Limits       | A/B/C         | C (configurable)          | ‚è≥ Pending  |
| 8. Heartbeat Interval  | 30/60/120s    | 60s                       | ‚è≥ Pending  |

---

## üéØ Meeting Outcomes (To Be Filled)

### Decisions Made

1. Lock Upgrade Flow: **************\_\_**************
2. Disconnect Handling: **************\_\_**************
3. Tab Lock Limits: **************\_\_**************
4. Admin Takeover: **************\_\_**************
5. Lock TTL: **************\_\_**************
6. Viewer Limits: **************\_\_**************
7. Heartbeat Interval: **************\_\_**************

### Action Items

- [ ] Backend: Update spec document with approved decisions
- [ ] UI Team: Review updated event payloads and TypeScript interfaces
- [ ] PM: Create JIRA tickets for Phase 1 tasks
- [ ] Security Consultant: Verify HIPAA compliance for viewer limits
- [ ] All: Review and approve implementation checklist

### Timeline Confirmation

- **Phase 1 Start**: Monday, November 18, 2025 @ 14:00
- **Phase 1 Delivery**: Monday, November 25, 2025 (9 days)
- **Phase 2 Start**: Tuesday, November 26, 2025
- **Phase 2 Delivery**: Monday, December 2, 2025 (16 days total)

### Blockers Identified

- ***
- ***

---

## üìé References

- **Technical Spec**: `docs/project/BE-001.3-LOCK-SPECIFICATION.md`
- **UI Team Feedback**: Message dated November 16, 2025
- **Backend Response**: `docs/BACKEND_RESPONSE_TO_UI_FEEDBACK.md`
- **Epic**: `docs/project/EPIC-001-websocket-gateway.md` (BE-001.3)
- **Roadmap**: `docs/project/ROADMAP.md` (Week 3-4)

---

**Document Version**: 1.0.0  
**Last Updated**: November 16, 2025  
**Status**: üìã Ready for Meeting (Monday, November 18, 2025 @ 10:00 AM)
